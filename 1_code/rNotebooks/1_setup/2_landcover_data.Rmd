
```{r setup, include=FALSE, cache=FALSE}
#Set root directory to R project root
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```



```{css, echo=FALSE}
# set max height of code chunks using the following css styling

pre {
  max-height: 300px;
  overflow-y: auto;
}

pre[class] {
  max-height: 500px;
}
```


```{r eval=FALSE}
library(dplyr)
library(stringr)
library(tmaptools)
library(tmap)
library(sf)
library(raster)
library(lubridate)
```



### CAS-FRI data {-}

#### Load CAS-FRI polygons {-}

Read ESRI geodatabase containing CAS-FRI, using sf package 


```{r eval=FALSE, echo=FALSE}
#  see layers in ESRI geodatabase

l<-st_layers(dsn="../../data/spatial/external/CASFRI/Alberta/alberta_geo.gdb")
l

# Driver: OpenFileGDB 
# Available layers:
#              layer_name geometry_type features fields
# 1           alberta_geo Multi Polygon  2632003     17
# 2     Alberta_dst_CO_25            NA       96      5
# 3     Alberta_dst_CO_50            NA      249      5
# 4     Alberta_dst_CO_95            NA     1684      5
# 5     Alberta_dst_CO_75            NA      395      5
# 6    Alberta_dst_CO_100            NA    22952      5
# 7 Alberta_dst_CO_DistRd Multi Polygon    14166      8
# 8   alberta_geo_project Multi Polygon  2631185      3



#Load alberta_geo (the CAS-FRI polygons)

cas_geo<-st_read(dsn="../../data/spatial/external/CASFRI/Alberta/alberta_geo.gdb", layer="alberta_geo")

cas_geo<-cas_geo[,1]


save(cas_geo, file="0_data/manual/CASFRI/cas_geo.rData")
```



#### Clip CAS-FRI to study area {-}

```{r eval=FALSE}
# load cas_geo
load("0_data/manual/spatialCov/CASFRI/cas_geo.rData")

# load study area
load("0_data/manual/bird/studyarea_big.rData")

#repair geometry of cas_geo
cas_geo1<-st_make_valid(cas_geo)

c_bb_tr<-st_transform(c_bb, st_crs(cas_geo1))
c_bb_tr_2<-st_bbox(c_bb_tr)
cas_geo_crop<-st_crop(cas_geo1, c_bb_tr_2)


# cas_geo_clip<-st_intersection(cas_geo, c_bb_tr)
cas_geo_crop_tr<-st_transform(cas_geo_crop, st_crs(c_bb))

cas_geo_crop_tr_1<-projectRaster(cas_geo_crop, crs = st_crs(c_bb)$proj4string)
test<-raster::projectRaster(cas_geo_crop, crs = projection(alberta))

cas_geo_crop<-cas_geo_crop[1]

cas_geo_crop<-st_buffer(cas_geo_crop, 0.0)
save(cas_geo_crop, file="0_data/manual/spatialCov/CASFRI/cas_geo_crop.rData")

##############################################################################
##Plot the clipped CAS-FRI polygons

#set up basemap
base<-read_osm(c_bb, type="bing", minNumTiles = 10)

# stations
load("0_data/manual/bird/ss_xy.rData")

#alberta boundary
alberta<-st_read("../../data/spatial/external/Alberta_Boundaries_and_Roads/Alberta/Alberta.shp")



mainmap<-tm_shape(base)+
  tm_rgb(alpha=.8)+ # to color the satelite basemap
  # tm_shape(c_bb)+
  # tm_fill(col="white", alpha=.7)+
  tm_shape(cas_geo_crop)+
  tm_borders(col="black")+
  tm_shape(ss_xy)+
    tm_symbols(shape = 4, alpha = 1, size = .6, col = "red")+
  tm_scale_bar(position=c("left", "BOTTOM"), text.color = "black", color.light="lightgrey")+
  tm_graticules(lines=FALSE)+
  tm_legend(outside=TRUE)

insetmap<-tm_shape(alberta)+tm_fill(col="lightgrey")+tm_borders(lwd=.9, col="black")+
  tm_shape(c_bb)+tm_borders(lw=2, col="red") +
  tm_layout(inner.margins = c(0.04,0.04,0.04,0.04), outer.margins=c(0,0,0,0), bg.color="transparent", frame = FALSE)
    #tm_symbols(shape = 20, alpha = .5, border.col="dimgray", size = .1, col = "black")
  #tm_legend(position=c("left", "top"), frame=TRUE)

#Get aspect ratio of bounding box
c_bb_2<-st_bbox(c_bb)
asp <- (c_bb_2$ymax - c_bb_2$ymin)/(c_bb_2$xmax - c_bb_2$xmin)


library(grid)
w <- 1
h <- asp * w
vp <- viewport(0.7, 0.33, width = w, height=h)
#vp <- viewport(0.9, 0.22, width = w, height=h, just=c("right", "top"))

tmap_save(mainmap,filename="3_output/maps/casfri_inset.png",
          dpi=300, insets_tm=insetmap, insets_vp=vp,
          height=asp*350, width=350, units="mm")
```

```{r map_fCASFRI_plot, echo=FALSE, fig.cap= "CASFRI landcover polygons", out.width = '100%'}
knitr::include_graphics("3_output/maps/casfri_inset.png")
```

#### Add LiDAR acquistion date to CAS_FRI polygons
```{r eval=FALSE}
acqDate<-st_read("../../data/spatial/external/Alberta_Landcover_Data/LiDAR/GOA_LiDAR_Alberta/from_ChrisBater/lidar_acquisitions/acquisition_date.shp")

acqDate<-st_transform(acqDate, crs = st_crs(cas_geo_crop))
cas_geo_crop_lidarDate<-st_join(cas_geo_crop,acqDate)
cas_geo_crop_lidarDate$date-as.Date(cas_geo_crop_lidarDate$date)
cas_geo_crop_lidarDate$year<-year(cas_geo_crop_lidarDate$date)

save(cas_geo_crop_lidarDate, file="0_data/manual/spatialCov/CASFRI/cas_geo_crop_lidarDate.rData")
```


#### Spatial join point count locations with CAS-FRI polygons {-}


```{r eval=FALSE}
#load clipped cas-fri polygons
load("0_data/manual/spatialCov/CASFRI/cas_geo_clip.rData")
# load point count locations
load("0_data/manual/bird/ss_xy.rData")

#transform crs of station locations to match the CAS-FRI polygons
ss_xy_tr<-st_transform(ss_xy, st_crs(cas_geo))

#add CAS-FRI ids to station data
ss_xy_cas<-st_join(ss_xy_tr, cas_geo)
# transform back to original crs
ss_xy_tr<-st_transform(ss_xy_cas, st_crs(ss_xy))


save(ss_xy_cas, file ="0_data/manual/spatialCov/CASFRI/ss_xy_cas.rData")

```

#### Or...bring in cas-fri station data from another chapter {-}

```{r eval=FALSE}
load("../../chapter_3/empirical/2_pipeline/tmp/bd_xy_cas.rData")
load("0_data/manual/bird/ss_xy.rData")

test<-left_join(as.data.frame(ss_xy), as.data.frame(bd_xy_cas), by="SS")

x<-as.data.frame(ss_xy)%>%
  select(SS)
y<-as.data.frame(bd_xy_cas)%>%
  select(SS, cas_id)

ss_cas<-left_join(x, y)
save(ss_cas, file ="0_data/manual/spatialCov/CASFRI/ss_cas.rData")

```

```{r echo=FALSE, message = FALSE, results="asis"}
load("0_data/manual/spatialCov/CASFRI/ss_cas.rData")

knitr::kable(head(ss_cas)) %>%
  kable_styling(font_size = 10, bootstrap_options= c("striped", "hover", "condensed" ), full_width= F, position="center") %>%
  column_spec(1, width= "20em")%>%
  scroll_box(width = "100%", height = "400px")
```




#### extract data on stand age and disturbance history {-}

```{r eval=FALSE}
###################################
# load disturbance data
###################################
cas_dst<-read.csv("../../data/spatial/external/CASFRI/Alberta/alberta_dst.csv")
#filter to only first layer
cas_dst<-filter(cas_dst, layer=="1")

###################################
# load forest data 
###################################
cas_lyr<-read.csv("../../data/spatial/external/CASFRI/Alberta/alberta_lyr.csv")
#filter to only first layer
cas_lyr<-filter(cas_lyr, layer=="1" & layer_rank=="1")

#forest type
   c#filter to only first layer
cas_forestType<-cas_forestType%>%
  rename(cas_id=Expr1)


###################################
# Join CASFRI covariates into a single data frame
###################################
cas_cov<-left_join(cas_lyr, cas_forestType,  by="cas_id")
cas_cov<-left_join(cas_cov, cas_dst, by="cas_id")

#change missing tree/forest type values to NA
d2<-cas_cov

d2[ d2 == -1111 ] <- NA 
d2[ d2 == -8888 ] <- NA 
#d2[29:47][ d2[28:46] == "XXXX MISS" ] <- NA     

d2$PercentDecid[ d2$Forest_Type == "" ] <- NA
d2$PercentConif[ d2$Forest_Type == "" ] <- NA
d2$Forest_Type[ d2$Forest_Type == "" ] <- NA

d2$dist_ext_upper_1<-as.factor(d2$dist_ext_upper_1)
d2$dist_ext_upper_2<-as.factor(d2$dist_ext_upper_2)


cas_cov<-d2

###################################
# Filter to calling lake
###################################     
ss_cas_cov<-left_join(ss_cas, cas_cov)

save(cas_cov, file="0_data/manual/spatialCov/CASFRI/cas_cov.rData")
save(ss_cas_cov, file="0_data/manual/spatialCov/CASFRI/ss_cas_cov.rData")
```

```{r echo=FALSE, message = FALSE, results="asis"}
load("0_data/manual/spatialCov/CASFRI/cas_cov.rData")

knitr::kable(head(cas_cov)) %>%
  kable_styling(font_size = 10, bootstrap_options= c("striped", "hover", "condensed" ), full_width= F, position="center") %>%
  column_spec(1, width= "20em")%>%
  scroll_box(width = "100%", height = "400px")
```




##### Load pointcount data {-}

```{r eval=FALSE}
load("0_data/manual/bird/bird_callingLake_wide_5.rData")
pkey_cas_cov<-bird_callingLake_wide_5%>%
  select(SS, PKEY, ss_year) %>%
  left_join(ss_cas_cov)
```

##### calculate forest age at time of LiDAR {-}
```{r}
cas_lyr<-read.csv("../../data/spatial/external/CASFRI/Alberta/alberta_lyr.csv")
cas_dst<-read.csv("../../data/spatial/external/CASFRI/Alberta/alberta_dst.csv")

cas_lyr2<-dplyr::filter(cas_lyr, layer=="1" & layer_rank=="1")%>%
  left_join(cas_dst)%>%
  mutate(forest_origin_year=coalesce(origin_upper, dist_yr_1))%>%
  dplyr::select(cas_id, forest_origin_year, dist_1)

load("0_data/manual/spatialCov/CASFRI/cas_geo_crop_lidarDate.rData")

cas_geo_crop_lidarDate_age<-cas_geo_crop_lidarDate%>%
  left_join(cas_lyr2)%>%
  mutate(lidar_forest_age=year-forest_origin_year)

save(cas_geo_crop_lidarDate_age, file="0_data/manual/spatialCov/CASFRI/cas_geo_crop_lidarDate_age.rData")

```

###### Create forest age raster {-}

```{r eval=FALSE}
load("0_data/manual/spatialCov/CASFRI/cas_geo_crop_lidarDate_age.rData")



#create the extent and the raster
e <- extent(cas_geo_crop_lidarDate_age)

#use study area aspect ration to calculate ncol and nrow for raster: #h=0.4444444 * w 
r <- raster::raster(e, crs= st_crs(cas_geo_crop_lidarDate_age)$proj4string, resolution = c(10, 10)) 

#remove error values
lidar_forestAge<-cas_geo_crop_lidarDate_age%>%
  dplyr::filter(lidar_forest_age<300)

# vreate forest age raster using rasterize
lidar_forestAge_raster<-raster::rasterize(lidar_forestAge, r, 'lidar_forest_age')

# save raster
writeRaster(lidar_forestAge_raster, filename = "0_data/manual/spatialCov/CASFRI/lidar_forestAge_raster", format="GTiff", overwrite=T)

```


##### calculate forest age at time of survey {-}

Get forest origin dates

```{r eval=FALSE}
### add forest origin year to cas_geo
load("0_data/manual/spatialCov/CASFRI/cas_cov.rData")
load("0_data/manual/spatialCov/CASFRI/cas_geo_crop.rData")

origin<-cas_cov%>%
  dplyr::select(cas_id, origin_upper, dist_yr_1, dist_yr_2, dist_yr_3)%>%
  mutate(forest_origin_year=coalesce(origin_upper, dist_yr_1))%>% # if upper origin is NA and there was a disturbance, replace NA with disturbance year.
  dplyr::select(cas_id, forest_origin_year)

cas_geo_crop_originYr<-left_join(cas_geo_crop, origin)

#plot
##############################################################################
##Plot the clipped CAS-FRI polygons and color by forest age

# stations
load("0_data/manual/bird/ss_xy.rData")

#alberta boundary
alberta<-st_read("../../data/spatial/external/Alberta_Boundaries_and_Roads/Alberta/Alberta.shp")


#set up basemap
base<-read_osm(c_bb, type="bing", minNumTiles = 10)

mainmap<-tm_shape(base)+
  tm_rgb(alph=.8)+ # to color the satelite basemap
  tm_shape(cas_geo_crop_originYr)+
  tm_fill(col = "forest_origin_year", 
              style = "quantile",
              palette = "BuGn",
              legend.hist = TRUE) +
  #tm_fill(col="forest_origin_year")+
  tm_shape(ss_xy)+
    tm_symbols(shape = 4, alpha = 1, size = .6, col = "red")+
  tm_scale_bar(position=c("left", "BOTTOM"), text.color = "black", color.light="lightgrey")+
  tm_graticules(lines=FALSE)+
  tm_legend(outside=TRUE)

insetmap<-tm_shape(alberta)+tm_fill(col="lightgrey")+tm_borders(lwd=.9, col="black")+
  tm_shape(c_bb)+tm_borders(lw=2, col="red") +
  tm_layout(inner.margins = c(0.04,0.04,0.04,0.04), outer.margins=c(0,0,0,0), bg.color="transparent", frame = FALSE)
    #tm_symbols(shape = 20, alpha = .5, border.col="dimgray", size = .1, col = "black")
  #tm_legend(position=c("left", "top"), frame=TRUE)

#Get aspect ratio of bounding box
c_bb_2<-st_bbox(c_bb)
asp <- (c_bb_2$ymax - c_bb_2$ymin)/(c_bb_2$xmax - c_bb_2$xmin)


library(grid)
w <- .8
h <- asp * w
vp <- viewport(0.7, 0.3, width = w, height=h)

tmap_save(mainmap,filename="3_output/maps/casfri_forestYear_inset.png",
          dpi=300, insets_tm=insetmap, insets_vp=vp,
          height=asp*350, width=350, units="mm")

#####################################
## Rasterize origin year polygons
#####################################


#create the extent and the raster
e <- extent(cas_geo_crop_originYr)

#use study area aspect ration to calculate ncol and nrow for raster: #h=0.4444444 * w 
r <- raster::raster(e, crs= st_crs(cas_geo_crop_originYr)$proj4string, resolution = c(10, 10)) 

# convert cas_geo to raster
cas_geo_crop_originYr_raster<-raster::rasterize(cas_geo_crop_originYr, r, 'forest_origin_year')

# save raster
writeRaster(cas_geo_crop_originYr_raster, filename = "0_data/manual/spatialCov/CASFRI/cas_geo_crop_originYr_raster", format="GTiff", overwrite=T)

 writeRaster(x, filename=paste0('0_data/manual/spatialCov/LiDAR/LiDAR_mosaics/',bl[j]), format="GTiff",  overwrite=T) 

#change resolution of raster for printing
r10<-aggregate(cas_geo_crop_originYr_raster, fact=10)

mainmap<-tm_shape(c_bb)+
  tm_borders(col="white")+ # to color the satelite basemap
  tm_shape(r10)+
  tm_raster(style = "cont",title="Canopy relief ratio", breaks = NULL,
            palette = "BuGn")+
  tm_shape(ss_xy)+
    tm_symbols(shape = 4, alpha = 1, size = .6, col = "red")+
  tm_scale_bar(position=c("left", "BOTTOM"), text.color = "black", color.light="lightgrey")+
  tm_graticules(lines=FALSE)+
  tm_legend(outside=TRUE)

tmap_save(mainmap,filename="3_output/maps/cas_geo_crop_originYr_raster.png",
          dpi=300, insets_tm=insetmap, insets_vp=vp,
          height=asp*350, width=350, units="mm")
```


```{r map_fCASFRI_plot, echo=FALSE, fig.cap= "CASFRI landcover polygons colored by forest age.", out.width = '100%'}
knitr::include_graphics("3_output/maps/casfri_forestYear_inset.png")
```

```{r map_fCASFRI_plot, echo=FALSE, fig.cap= "CASFRI landcover forest age raster.", out.width = '100%'}
knitr::include_graphics("3_output/maps/cas_geo_crop_originYr_raster.png")
```



```{r eval=FALSE}
load("0_data/manual/spatialCov/CASFRI/pkey_cas_cov.rData")
pkey_cas_cov$poly_forest_age<-pkey_cas_cov$ss_year-pkey_cas_cov$origin_upper

#plot
##############################################################################
##Plot the clipped CAS-FRI polygons and color by forest age

load("0_data/manual/spatialCov/CASFRI/cas_geo_crop.rData")
#load("0_data/manual/spatialCov/CASFRI/pkey_cas_cov.rData")
x<-pkey_cas_cov%>%
  select(cas_id, forest_age, PKEY)%>%
  filter(forest_age>=0)

y<-inner_join(cas_geo_crop, x)

# stations
load("0_data/manual/bird/ss_xy.rData")

#alberta boundary
alberta<-st_read("../../data/spatial/external/Alberta_Boundaries_and_Roads/Alberta/Alberta.shp")



#set up basemap
base<-read_osm(c_bb, type="bing", minNumTiles = 10)

mainmap<-tm_shape(base)+
  tm_rgb(alph=.8)+ # to color the satelite basemap
  tm_shape(y)+
  tm_fill(col="forest_age")+
  tm_shape(ss_xy)+
    tm_symbols(shape = 4, alpha = 1, size = .6, col = "red")+
  tm_scale_bar(position=c("left", "BOTTOM"), text.color = "black", color.light="lightgrey")+
  tm_graticules(lines=FALSE)+
  tm_legend(outside=TRUE)

insetmap<-tm_shape(alberta)+tm_fill(col="lightgrey")+tm_borders(lwd=.9, col="black")+
  tm_shape(c_bb)+tm_borders(lw=2, col="red") +
  tm_layout(inner.margins = c(0.04,0.04,0.04,0.04), outer.margins=c(0,0,0,0), bg.color="transparent", frame = FALSE)
    #tm_symbols(shape = 20, alpha = .5, border.col="dimgray", size = .1, col = "black")
  #tm_legend(position=c("left", "top"), frame=TRUE)

#Get aspect ratio of bounding box
c_bb_2<-st_bbox(c_bb)
asp <- (c_bb_2$ymax - c_bb_2$ymin)/(c_bb_2$xmax - c_bb_2$xmin)


library(grid)
w <- 1
h <- asp * w
vp <- viewport(0.7, 0.33, width = w, height=h)
#vp <- viewport(0.9, 0.22, width = w, height=h, just=c("right", "top"))

tmap_save(mainmap,filename="3_output/maps/casfri_forestAge_inset.png",
          dpi=300, insets_tm=insetmap, insets_vp=vp,
          height=asp*350, width=350, units="mm")


```

```{r map_fCASFRI_plot, echo=FALSE, fig.cap= "CASFRI landcover polygons colored by forest age.", out.width = '100%'}

knitr::include_graphics("3_output/maps/casfri_forestAge_inset.png")
```

###### Extract stand origin date raster values to points

```{r eval=FALSE}

r<-raster("0_data/manual/spatialCov/CASFRI/cas_geo_crop_originYr_raster.tif")

ss_forest_origDate_mean<-extract(r,ss_xy, buffer=100, na.rm=TRUE, fun=mean)
save(ss_forest_origDate_mean, file="2_pipeline/tmp/ss_forest_origDate_mean.rData")

ss_forest_origDate_sd<-extract(r,ss_xy, buffer=100, na.rm=TRUE, fun=sd) 
save(ss_forest_origDate_sd, file="2_pipeline/tmp/ss_forest_origDate_sd.rData")

ss_forest_origDate_mean<-round(ss_forest_origDate_mean,0)
ss_forest_origDate_sd<-round(ss_forest_origDate_sd,2)

SS_forest_origDate_mean_sd<-as.data.frame(cbind(ss_xy, ss_forest_origDate_mean, ss_forest_origDate_sd))%>%
  dplyr::select(-geometry)

save(SS_forest_origDate_mean_sd, file="2_pipeline/tmp/SS_forest_origDate_mean_sd")
```

##### Calculate forest age based on mean raster values

```{r eval=FALSE}
x<-left_join(pkey_cas_cov, SS_forest_origDate_mean_sd)
x$rast_forest_age<-x$ss_year-x$ss_forest_origDate_mean
x<-x[c(1:5, 58, 36, 56:57, 7:35, 37:55)]

pkey_cas_cov<-x
pkey_cas_cov<-pkey_cas_cov[c(1:6, 38:39, 7:37, 40:57)]
```



##### calculate time since disturbance {-}

```{r eval=FALSE}
pkey_cas_cov$ss_dst_timelag<-pkey_cas_cov$ss_year-pkey_cas_cov$dist_yr_1

pkey_cas_cov<-pkey_cas_cov[c(1:2,4,3,54:55,5:53)]
save(pkey_cas_cov, file="0_data/manual/spatialCov/CASFRI/pkey_cas_cov.rData")
```


##### Calculate Forest age classes {-}

0 0-9 stand initiation: shrub-herb
1 10-19 late stand initiation: sapling
2 20-33 early stem exclusion
3 34-80 late stem exclusion
4 81-99 early canopy transition
5 100+late canopy transition/gap dynamics


```{r eval=FALSE}
load("0_data/manual/spatialCov/CASFRI/pkey_cas_cov.rData")

x<-pkey_cas_cov
hist(x$rast_forest_age)
x$forest_age_class_r <- cut(
  x$rast_forest_age,
  breaks = c(0, 10, 20, 34, 81, 100, Inf),
  labels = c("0", "1", "2", "3", "4", "5"),
  right  = FALSE
)
#plot(x$forest_age_class_r)

x$forest_age_class_p <- cut(
  x$poly_forest_age,
  breaks = c(0, 10, 20, 34, 81, 100, Inf),
  labels = c("0", "1", "2", "3", "4", "5"),
  right  = FALSE
)

#plot(x$forest_age_class_p)
#compare forest age class from polygons vs forest age class from raster
x1<-x[c(2,6, 58)]%>%
  rename(forest_age_class=forest_age_class_r)
x2<-x[c(2,59)]%>%
  rename(forest_age_class=forest_age_class_p)
aj<-anti_join(x1,x2)

pkey_cas_cov<-x

save(pkey_cas_cov, file="0_data/manual/spatialCov/CASFRI/pkey_cas_cov.rData")

```

###### Create forest age class raster {-}
```{r eval=FALSE}
#create survey forest age rasters for each time step
lidar_forestAge_raster<-raster("0_data/manual/spatialCov/CASFRI/lidar_forestAge_raster.tif")

#create survey forest age rasters for each time step
lidar_forestAge_raster_00	<-lidar_forestAge_raster-00
lidar_forestAge_raster_01	<-lidar_forestAge_raster-01
lidar_forestAge_raster_02	<-lidar_forestAge_raster-02
lidar_forestAge_raster_03	<-lidar_forestAge_raster-03
lidar_forestAge_raster_04	<-lidar_forestAge_raster-04
lidar_forestAge_raster_05	<-lidar_forestAge_raster-05
lidar_forestAge_raster_06	<-lidar_forestAge_raster-06
lidar_forestAge_raster_07	<-lidar_forestAge_raster-07
lidar_forestAge_raster_08	<-lidar_forestAge_raster-08
lidar_forestAge_raster_09	<-lidar_forestAge_raster-09
lidar_forestAge_raster_10	<-lidar_forestAge_raster-10
lidar_forestAge_raster_11	<-lidar_forestAge_raster-11
lidar_forestAge_raster_12	<-lidar_forestAge_raster-12
lidar_forestAge_raster_13	<-lidar_forestAge_raster-13
lidar_forestAge_raster_14	<-lidar_forestAge_raster-14
lidar_forestAge_raster_15	<-lidar_forestAge_raster-15
lidar_forestAge_raster_16	<-lidar_forestAge_raster-16
lidar_forestAge_raster_plus01	<-lidar_forestAge_raster-01
lidar_forestAge_raster_plus02	<-lidar_forestAge_raster-02
lidar_forestAge_raster_plus03	<-lidar_forestAge_raster-03
lidar_forestAge_raster_plus04	<-lidar_forestAge_raster-04
lidar_forestAge_raster_plus05	<-lidar_forestAge_raster-05
lidar_forestAge_raster_plus06	<-lidar_forestAge_raster-06


#Make negative values NA
lidar_forestAge_raster_00[lidar_forestAge_raster_00<0]<-NA
lidar_forestAge_raster_01[lidar_forestAge_raster_01<0]<-NA
lidar_forestAge_raster_02[lidar_forestAge_raster_02<0]<-NA
lidar_forestAge_raster_03[lidar_forestAge_raster_03<0]<-NA
lidar_forestAge_raster_04[lidar_forestAge_raster_04<0]<-NA
lidar_forestAge_raster_05[lidar_forestAge_raster_05<0]<-NA
lidar_forestAge_raster_06[lidar_forestAge_raster_06<0]<-NA
lidar_forestAge_raster_07[lidar_forestAge_raster_07<0]<-NA
lidar_forestAge_raster_08[lidar_forestAge_raster_08<0]<-NA
lidar_forestAge_raster_09[lidar_forestAge_raster_09<0]<-NA
lidar_forestAge_raster_10[lidar_forestAge_raster_10<0]<-NA
lidar_forestAge_raster_11[lidar_forestAge_raster_11<0]<-NA
lidar_forestAge_raster_12[lidar_forestAge_raster_12<0]<-NA
lidar_forestAge_raster_13[lidar_forestAge_raster_13<0]<-NA
lidar_forestAge_raster_14[lidar_forestAge_raster_14<0]<-NA
lidar_forestAge_raster_15[lidar_forestAge_raster_15<0]<-NA
lidar_forestAge_raster_16[lidar_forestAge_raster_16<0]<-NA
lidar_forestAge_raster_plus01[lidar_forestAge_raster_plus01<0]<-NA
lidar_forestAge_raster_plus02[lidar_forestAge_raster_plus02<0]<-NA
lidar_forestAge_raster_plus03[lidar_forestAge_raster_plus03<0]<-NA
lidar_forestAge_raster_plus04[lidar_forestAge_raster_plus04<0]<-NA
lidar_forestAge_raster_plus05[lidar_forestAge_raster_plus05<0]<-NA
lidar_forestAge_raster_plus06[lidar_forestAge_raster_plus06<0]<-NA


writeRaster(lidar_forestAge_raster_00, filename = "0_data/manual/spatialCov/CASFRI/AgeRasters/Age_00", format="GTiff", overwrite=T)
writeRaster(lidar_forestAge_raster_01, filename = "0_data/manual/spatialCov/CASFRI/AgeRasters/Age_01", format="GTiff", overwrite=T)
writeRaster(lidar_forestAge_raster_02, filename = "0_data/manual/spatialCov/CASFRI/AgeRasters/Age_02", format="GTiff", overwrite=T)
writeRaster(lidar_forestAge_raster_03, filename = "0_data/manual/spatialCov/CASFRI/AgeRasters/Age_03", format="GTiff", overwrite=T)
writeRaster(lidar_forestAge_raster_04, filename = "0_data/manual/spatialCov/CASFRI/AgeRasters/Age_04", format="GTiff", overwrite=T)
writeRaster(lidar_forestAge_raster_05, filename = "0_data/manual/spatialCov/CASFRI/AgeRasters/Age_05", format="GTiff", overwrite=T)
writeRaster(lidar_forestAge_raster_06, filename = "0_data/manual/spatialCov/CASFRI/AgeRasters/Age_06", format="GTiff", overwrite=T)
writeRaster(lidar_forestAge_raster_07, filename = "0_data/manual/spatialCov/CASFRI/AgeRasters/Age_07", format="GTiff", overwrite=T)
writeRaster(lidar_forestAge_raster_08, filename = "0_data/manual/spatialCov/CASFRI/AgeRasters/Age_08", format="GTiff", overwrite=T)
writeRaster(lidar_forestAge_raster_09, filename = "0_data/manual/spatialCov/CASFRI/AgeRasters/Age_09", format="GTiff", overwrite=T)
writeRaster(lidar_forestAge_raster_10, filename = "0_data/manual/spatialCov/CASFRI/AgeRasters/Age_10", format="GTiff", overwrite=T)
writeRaster(lidar_forestAge_raster_11, filename = "0_data/manual/spatialCov/CASFRI/AgeRasters/Age_11", format="GTiff", overwrite=T)
writeRaster(lidar_forestAge_raster_12, filename = "0_data/manual/spatialCov/CASFRI/AgeRasters/Age_12", format="GTiff", overwrite=T)
writeRaster(lidar_forestAge_raster_13, filename = "0_data/manual/spatialCov/CASFRI/AgeRasters/Age_13", format="GTiff", overwrite=T)
writeRaster(lidar_forestAge_raster_14, filename = "0_data/manual/spatialCov/CASFRI/AgeRasters/Age_14", format="GTiff", overwrite=T)
writeRaster(lidar_forestAge_raster_15, filename = "0_data/manual/spatialCov/CASFRI/AgeRasters/Age_15", format="GTiff", overwrite=T)
writeRaster(lidar_forestAge_raster_16, filename = "0_data/manual/spatialCov/CASFRI/AgeRasters/Age_16", format="GTiff", overwrite=T)
writeRaster(lidar_forestAge_raster_plus01, filename = "0_data/manual/spatialCov/CASFRI/AgeRasters/Age_plus01", format="GTiff", overwrite=T)
writeRaster(lidar_forestAge_raster_plus02, filename = "0_data/manual/spatialCov/CASFRI/AgeRasters/Age_plus02", format="GTiff", overwrite=T)
writeRaster(lidar_forestAge_raster_plus03, filename = "0_data/manual/spatialCov/CASFRI/AgeRasters/Age_plus03", format="GTiff", overwrite=T)
writeRaster(lidar_forestAge_raster_plus04, filename = "0_data/manual/spatialCov/CASFRI/AgeRasters/Age_plus04", format="GTiff", overwrite=T)
writeRaster(lidar_forestAge_raster_plus05, filename = "0_data/manual/spatialCov/CASFRI/AgeRasters/Age_plus05", format="GTiff", overwrite=T)
writeRaster(lidar_forestAge_raster_plus06, filename = "0_data/manual/spatialCov/CASFRI/AgeRasters/Age_plus06", format="GTiff", overwrite=T)

# create a raster stack
#list the files
Age_list<-list.files(path='0_data/manual/spatialCov/CASFRI/AgeRasters', pattern = "*.tif$", full.names = TRUE)
Age_stack<-raster::stack(Age_list)

#save stack as r object
stackSave(Age_stack,file="0_data/manual/spatialCov/CASFRI/AgeRasters/Age_stack.stk")


##########################################################
#Create forest class rasters
# create classification matrix
reclass_df <- c(0, 9, 0,
              9, 19, 1,
             19, 33, 2,
             33, 80, 3,
             80, 99, 4,
             99, Inf, 5)
reclass_df

# reshape the object into a matrix with columns and rows
reclass_m <- matrix(reclass_df,
                ncol = 3,
                byrow = TRUE)
#reclassify raster
lidar_forestAgeClass_raster_00<-reclassify(lidar_forestAge_raster_00, reclass_m)
lidar_forestAgeClass_raster_01<-reclassify(lidar_forestAge_raster_01, reclass_m)
lidar_forestAgeClass_raster_02<-reclassify(lidar_forestAge_raster_02, reclass_m)
lidar_forestAgeClass_raster_03<-reclassify(lidar_forestAge_raster_03, reclass_m)
lidar_forestAgeClass_raster_04<-reclassify(lidar_forestAge_raster_04, reclass_m)
lidar_forestAgeClass_raster_05<-reclassify(lidar_forestAge_raster_05, reclass_m)
lidar_forestAgeClass_raster_06<-reclassify(lidar_forestAge_raster_06, reclass_m)
lidar_forestAgeClass_raster_07<-reclassify(lidar_forestAge_raster_07, reclass_m)
lidar_forestAgeClass_raster_08<-reclassify(lidar_forestAge_raster_08, reclass_m)
lidar_forestAgeClass_raster_09<-reclassify(lidar_forestAge_raster_09, reclass_m)
lidar_forestAgeClass_raster_10<-reclassify(lidar_forestAge_raster_10, reclass_m)
lidar_forestAgeClass_raster_11<-reclassify(lidar_forestAge_raster_11, reclass_m)
lidar_forestAgeClass_raster_12<-reclassify(lidar_forestAge_raster_12, reclass_m)
lidar_forestAgeClass_raster_13<-reclassify(lidar_forestAge_raster_13, reclass_m)
lidar_forestAgeClass_raster_14<-reclassify(lidar_forestAge_raster_14, reclass_m)
lidar_forestAgeClass_raster_15<-reclassify(lidar_forestAge_raster_15, reclass_m)
lidar_forestAgeClass_raster_16<-reclassify(lidar_forestAge_raster_16, reclass_m)

lidar_forestAgeClass_raster_plus01<-reclassify(lidar_forestAge_raster_plus01, reclass_m)
lidar_forestAgeClass_raster_plus02<-reclassify(lidar_forestAge_raster_plus02, reclass_m)
lidar_forestAgeClass_raster_plus03<-reclassify(lidar_forestAge_raster_plus03, reclass_m)
lidar_forestAgeClass_raster_plus04<-reclassify(lidar_forestAge_raster_plus04, reclass_m)
lidar_forestAgeClass_raster_plus05<-reclassify(lidar_forestAge_raster_plus05, reclass_m)
lidar_forestAgeClass_raster_plus06<-reclassify(lidar_forestAge_raster_plus06, reclass_m)

# 
# writeRaster(lidar_forestAge_raster, filename = "0_data/manual/spatialCov/CASFRI/lidar_forestAge_raster", format="GTiff", overwrite=T)

writeRaster(lidar_forestAgeClass_raster_00, filename = "0_data/manual/spatialCov/CASFRI/ageClassRasters/ageClass_00", format="GTiff", overwrite=T)
writeRaster(lidar_forestAgeClass_raster_01, filename = "0_data/manual/spatialCov/CASFRI/ageClassRasters/ageClass_01", format="GTiff", overwrite=T)
writeRaster(lidar_forestAgeClass_raster_02, filename = "0_data/manual/spatialCov/CASFRI/ageClassRasters/ageClass_02", format="GTiff", overwrite=T)
writeRaster(lidar_forestAgeClass_raster_03, filename = "0_data/manual/spatialCov/CASFRI/ageClassRasters/ageClass_03", format="GTiff", overwrite=T)
writeRaster(lidar_forestAgeClass_raster_04, filename = "0_data/manual/spatialCov/CASFRI/ageClassRasters/ageClass_04", format="GTiff", overwrite=T)
writeRaster(lidar_forestAgeClass_raster_05, filename = "0_data/manual/spatialCov/CASFRI/ageClassRasters/ageClass_05", format="GTiff", overwrite=T)
writeRaster(lidar_forestAgeClass_raster_06, filename = "0_data/manual/spatialCov/CASFRI/ageClassRasters/ageClass_06", format="GTiff", overwrite=T)
writeRaster(lidar_forestAgeClass_raster_07, filename = "0_data/manual/spatialCov/CASFRI/ageClassRasters/ageClass_07", format="GTiff", overwrite=T)
writeRaster(lidar_forestAgeClass_raster_08, filename = "0_data/manual/spatialCov/CASFRI/ageClassRasters/ageClass_08", format="GTiff", overwrite=T)
writeRaster(lidar_forestAgeClass_raster_09, filename = "0_data/manual/spatialCov/CASFRI/ageClassRasters/ageClass_09", format="GTiff", overwrite=T)
writeRaster(lidar_forestAgeClass_raster_10, filename = "0_data/manual/spatialCov/CASFRI/ageClassRasters/ageClass_10", format="GTiff", overwrite=T)
writeRaster(lidar_forestAgeClass_raster_11, filename = "0_data/manual/spatialCov/CASFRI/ageClassRasters/ageClass_11", format="GTiff", overwrite=T)
writeRaster(lidar_forestAgeClass_raster_12, filename = "0_data/manual/spatialCov/CASFRI/ageClassRasters/ageClass_12", format="GTiff", overwrite=T)
writeRaster(lidar_forestAgeClass_raster_13, filename = "0_data/manual/spatialCov/CASFRI/ageClassRasters/ageClass_13", format="GTiff", overwrite=T)
writeRaster(lidar_forestAgeClass_raster_14, filename = "0_data/manual/spatialCov/CASFRI/ageClassRasters/ageClass_14", format="GTiff", overwrite=T)
writeRaster(lidar_forestAgeClass_raster_15, filename = "0_data/manual/spatialCov/CASFRI/ageClassRasters/ageClass_15", format="GTiff", overwrite=T)
writeRaster(lidar_forestAgeClass_raster_16, filename = "0_data/manual/spatialCov/CASFRI/ageClassRasters/ageClass_16", format="GTiff", overwrite=T)
writeRaster(lidar_forestAgeClass_raster_plus01, filename = "0_data/manual/spatialCov/CASFRI/ageClassRasters/ageClass_plus01", format="GTiff", overwrite=T)
writeRaster(lidar_forestAgeClass_raster_plus02, filename = "0_data/manual/spatialCov/CASFRI/ageClassRasters/ageClass_plus02", format="GTiff", overwrite=T)
writeRaster(lidar_forestAgeClass_raster_plus03, filename = "0_data/manual/spatialCov/CASFRI/ageClassRasters/ageClass_plus03", format="GTiff", overwrite=T)
writeRaster(lidar_forestAgeClass_raster_plus04, filename = "0_data/manual/spatialCov/CASFRI/ageClassRasters/ageClass_plus04", format="GTiff", overwrite=T)
writeRaster(lidar_forestAgeClass_raster_plus05, filename = "0_data/manual/spatialCov/CASFRI/ageClassRasters/ageClass_plus05", format="GTiff", overwrite=T)
writeRaster(lidar_forestAgeClass_raster_plus06, filename = "0_data/manual/spatialCov/CASFRI/ageClassRasters/ageClass_plus06", format="GTiff", overwrite=T)

# create a raster stack
#list the files
ageClass_list<-list.files(path='0_data/manual/spatialCov/CASFRI/ageClassRasters', pattern = "*.tif$", full.names = TRUE)
ageClass_stack<-raster::stack(ageClass_list)

#save stack as r object
stackSave(ageClass_stack,file="0_data/manual/spatialCov/CASFRI/ageClassRasters/ageClass_stack.stk")

```


### 2005 MODIS Landcover {-}

http://www.cec.org/north-american-environmental-atlas/land-cover-2005-modis-250m/


```{r eval=FALSE}
#use the modis landcover data extracted for the QPAD offsets.
load("../../data/avian_lifeHistory/BAM_avianDatabase/AB-data-w-offsets-to-Brendan.RData")

# use dd for the habitat covariates the offsets were based on
callingLake_QPAD_LC<-dd%>%filter(str_detect(PKEY, "^CL"))

save(callingLake_QPAD_LC, file="0_data/manual/spatialCov/QPAD/callingLake_QPAD_LC.rData")

```


### Oceanic Niño Index (ONI) {-}

@lestonLongtermChangesBoreal2018

December January February
```{r eval=FALSE}
ONI<-read.csv("0_data/external/OceanicNinoIndex.csv")
```


### NDVI {-}

#### Calculate Landsat NDVI rasters {-}

We used the following code in Google Earth Engine to get landsat NDVI rasters for each survey year in our study area

```{js eval=FALSE}

//########################################################################################################
//##### INPUTS ##### 
//########################################################################################################




// Create geometry object,for study area
var geometry = /* color: #ffc82d */study_area.geometry();
print(geometry);
Map.addLayer(geometry);

// define a geometry - there are lots of ways to do this, see the GEE User guide
var aoi = geometry; // should be a GEE geometry object - here we are getting it from an drawn polygon
Map.addLayer(aoi);


// visualization parameters
var imageVisParam = {"opacity":1,"bands":["yr1985","yr2001","yr2017"],
"min":473.9825265803124,"max":915.2623445519782,"gamma":1};

// define years and dates to include in landsat image collection
var startYear  = 1990;    // what year do you want to start the time series 
// var endYear    = 2017;    // what year do you want to end the time series ***** Set to 2017, year of HFI 2017 HA polygons
//** New for 2018 HAs (2020-06-17)
var endYear    = 2020;    // what year do you want to end the time series ***** Set to survey year
var startDay   = '06-01'; // what is the beginning of date filter | month-day
var endDay     = '09-30'; // what is the end of date filter | month-day


// define function to calculate a spectral index to segment with LT
var segIndex = function(img) {
    var index = img.normalizedDifference(['B4', 'B7'])                      // calculate normalized difference of band 4 and band 7 (B4-B7)/(B4+B7)
                   .multiply(1000)                                          // ...scale results by 1000 so we can convert to int and retain some precision
                   .select([0], ['NBR'])                                    // ...name the band
                   .set('system:time_start', img.get('system:time_start')); // ...set the output system:time_start metadata to the input image time_start otherwise it is null
    return index ;
};


//########################################################################################################
//##### ANNUAL SR TIME SERIES COLLECTION BUILDING FUNCTIONS ##### 
//########################################################################################################


//----- MAKE A DUMMY COLLECTOIN FOR FILLTING MISSING YEARS -----
var dummyCollection = ee.ImageCollection([ee.Image([0,0,0,0,0,0]).mask(ee.Image(0))]); // make an image collection from an image with 6 bands all set to 0 and then make them masked values


//------ L8 to L7 HARMONIZATION FUNCTION -----
// slope and intercept citation: Roy, D.P., Kovalskyy, V., Zhang, H.K., Vermote, E.F., Yan, L., Kumar, S.S, Egorov, A., 2016, Characterization of Landsat-7 to Landsat-8 reflective wavelength and normalized difference vegetation index continuity, Remote Sensing of Environment, 185, 57-70.(http://dx.doi.org/10.1016/j.rse.2015.12.024); Table 2 - reduced major axis (RMA) regression coefficients
var harmonizationRoy = function(oli) {
  var slopes = ee.Image.constant([0.9785, 0.9542, 0.9825, 1.0073, 1.0171, 0.9949]);        // create an image of slopes per band for L8 TO L7 regression line - David Roy
  var itcp = ee.Image.constant([-0.0095, -0.0016, -0.0022, -0.0021, -0.0030, 0.0029]);     // create an image of y-intercepts per band for L8 TO L7 regression line - David Roy
  var y = oli.select(['B2','B3','B4','B5','B6','B7'],['B1', 'B2', 'B3', 'B4', 'B5', 'B7']) // select OLI bands 2-7 and rename them to match L7 band names
             .resample('bicubic')                                                          // ...resample the L8 bands using bicubic
             .subtract(itcp.multiply(10000)).divide(slopes)                                // ...multiply the y-intercept bands by 10000 to match the scale of the L7 bands then apply the line equation - subtract the intercept and divide by the slope
             .set('system:time_start', oli.get('system:time_start'));                      // ...set the output system:time_start metadata to the input image time_start otherwise it is null
  return y.toShort();                                                                       // return the image as short to match the type of the other data
};


//------ RETRIEVE A SENSOR SR COLLECTION FUNCTION -----
var getSRcollection = function(year, startDay, endDay, sensor, aoi) {
  // ** ADDED IN BY JEN HIRD:::: create startDate & endDate ee.Date objects for use in functions
  // because get error about bad date/time otherwise
  // ---------------------------------------------
  var mo1 = ee.Number.parse(startDay.substr(0,2));
  var day1 = ee.Number.parse(startDay.substr(3,2));
  var mo2 = ee.Number.parse(endDay.substr(0,2));
  var day2 = ee.Number.parse(endDay.substr(3,2));
  var startDate = ee.Date.fromYMD(year, mo1, day1);
  var endDate = ee.Date.fromYMD(year, mo2, day2);
  // ---------------------------------------------
  
  // get a landsat collection for given year, day range, and sensor
  var srCollection = ee.ImageCollection('LANDSAT/'+ sensor + '/C01/T1_SR') // get surface reflectance images
                       .filterBounds(aoi)                                  // ...filter them by intersection with AOI
                       .filterDate(startDate, endDate); //*** ADDED BY JH (to deal with bad date error) ***
                       //.filterDate(year+'-'+startDay, year+'-'+endDay);    // ...filter them by year and day range
  
  // apply the harmonization function to LC08 (if LC08), subset bands, unmask, and resample           
  srCollection = srCollection.map(function(img) {
    var dat = ee.Image(
      ee.Algorithms.If(
        sensor == 'LC08',                                                  // condition - if image is OLI
        harmonizationRoy(img.unmask()),                                    // true - then apply the L8 TO L7 alignment function after unmasking pixels that were previosuly masked (why/when are pixels masked)
        img.select(['B1', 'B2', 'B3', 'B4', 'B5', 'B7'])                   // false - else select out the reflectance bands from the non-OLI image
           .unmask()                                                       // ...unmask any previously masked pixels 
           .resample('bicubic')                                            // ...resample by bicubic 
           .set('system:time_start', img.get('system:time_start'))         // ...set the output system:time_start metadata to the input image time_start otherwise it is null
      )
    );
    
    // make a cloud, cloud shadow, and snow mask from fmask band
    var qa = img.select('pixel_qa');                                       // select out the fmask band
    var mask = qa.bitwiseAnd(8).eq(0).and(                                 // include shadow
               qa.bitwiseAnd(16).eq(0)).and(                               // include snow
               qa.bitwiseAnd(32).eq(0));                                   // include clouds
    
    // apply the mask to the image and return it
    return dat.mask(mask); //apply the mask - 0's in mask will be excluded from computation and set to opacity=0 in display
  });

  return srCollection; // return the prepared collection
};


//------ FUNCTION TO COMBINE LT05, LE07, & LC08 COLLECTIONS -----
var getCombinedSRcollection = function(year, startDay, endDay, aoi) {
    var lt5 = getSRcollection(year, startDay, endDay, 'LT05', aoi);       // get TM collection for a given year, date range, and area
    var le7 = getSRcollection(year, startDay, endDay, 'LE07', aoi);       // get ETM+ collection for a given year, date range, and area
    var lc8 = getSRcollection(year, startDay, endDay, 'LC08', aoi);       // get OLI collection for a given year, date range, and area
    var mergedCollection = ee.ImageCollection(lt5.merge(le7).merge(lc8)); // merge the individual sensor collections into one imageCollection object
    return mergedCollection;                                              // return the Imagecollection
};


//------ FUNCTION TO REDUCE COLLECTION TO SINGLE IMAGE PER YEAR BY MEDOID -----
/*
  LT expects only a single image per year in a time series, there are lost of ways to
  do best available pixel compositing - we have found that a mediod composite requires little logic
  is robust, and fast
  
  Medoids are representative objects of a data set or a cluster with a data set whose average 
  dissimilarity to all the objects in the cluster is minimal. Medoids are similar in concept to 
  means or centroids, but medoids are always members of the data set.
*/

// make a medoid composite with equal weight among indices
var medoidMosaic = function(inCollection, dummyCollection) {
  
  // fill in missing years with the dummy collection
  var imageCount = inCollection.toList(1).length();                                                            // get the number of images 
  var finalCollection = ee.ImageCollection(ee.Algorithms.If(imageCount.gt(0), inCollection, dummyCollection)); // if the number of images in this year is 0, then use the dummy collection, otherwise use the SR collection
  
  // calculate median across images in collection per band
  var median = finalCollection.median();                                                                       // calculate the median of the annual image collection - returns a single 6 band image - the collection median per band
  
  // calculate the different between the median and the observation per image per band
  var difFromMedian = finalCollection.map(function(img) {
    var diff = ee.Image(img).subtract(median).pow(ee.Image.constant(2));                                       // get the difference between each image/band and the corresponding band median and take to power of 2 to make negatives positive and make greater differences weight more
    return diff.reduce('sum').addBands(img);                                                                   // per image in collection, sum the powered difference across the bands - set this as the first band add the SR bands to it - now a 7 band image collection
  });
  
  // get the medoid by selecting the image pixel with the smallest difference between median and observation per band 
  return ee.ImageCollection(difFromMedian).reduce(ee.Reducer.min(7)).select([1,2,3,4,5,6], ['B1','B2','B3','B4','B5','B7']); // find the powered difference that is the least - what image object is the closest to the median of teh collection - and then subset the SR bands and name them - leave behind the powered difference band
};


//------ FUNCTION TO APPLY MEDOID COMPOSITING FUNCTION TO A COLLECTION -------------------------------------------
var buildMosaic = function(year, startDay, endDay, aoi, dummyCollection) {                                                                      // create a temp variable to hold the upcoming annual mosiac
  var collection = getCombinedSRcollection(year, startDay, endDay, aoi);  // get the SR collection
  var img = medoidMosaic(collection, dummyCollection)                     // apply the medoidMosaic function to reduce the collection to single image per year by medoid 
              .set('system:time_start', (new Date(year,8,1)).valueOf());  // add the year to each medoid image - the data is hard-coded Aug 1st 
  return ee.Image(img);                                                   // return as image object
};


//------ FUNCTION TO BUILD ANNUAL MOSAIC COLLECTION ------------------------------
var buildMosaicCollection = function(startYear, endYear, startDay, endDay, aoi, dummyCollection) {
  var imgs = [];                                                                    // create empty array to fill
  for (var i = startYear; i <= endYear; i++) {                                      // for each year from hard defined start to end build medoid composite and then add to empty img array
    var tmp = buildMosaic(i, startDay, endDay, aoi, dummyCollection);               // build the medoid mosaic for a given year
    imgs = imgs.concat(tmp.set('system:time_start', (new Date(i,8,1)).valueOf()));  // concatenate the annual image medoid to the collection (img) and set the date of the image - hard coded to the year that is being worked on for Aug 1st
  }
  return ee.ImageCollection(imgs);                                                  // return the array img array as an image collection
};



//********************************************************************************************************
//****************************** *JH FUNCTIONS*: BUILD MEDIAN COMPOSITE TS *******************************
//********************************************************************************************************

//== Function for computing median per summer season from an image collection
var calcSeasonalMedian = function(imgCollection, yr){
  var sysTime = ee.Image(imgCollection.first()).get('system:time_start');
  var seasMed = imgCollection.median();
  var year = ee.Image(ee.Number(yr)).rename("YEAR");
  return seasMed.set('year', yr).set('system:time_start',sysTime).addBands(year).toFloat();
};

//== Create sequential list of years 
var ltYrs = ee.List.sequence(startYear, endYear);

//== For each year in sequence, create a combined Landsat surface reflectance image collection,
//== and apply seasonal median function to create a single composite
var buildAnnualMedian = ltYrs.map(function(yr){
  var comboCollec = getCombinedSRcollection(yr, startDay, endDay, aoi);
  var medComp = calcSeasonalMedian(comboCollec, yr);
  return medComp;
});

//== Define function to calculate a spectral index to segment with LT (SOURCE: LandTrendr segIndex function)
var NBRindex = function(img) {
    var index = img.normalizedDifference(['B4', 'B7'])                      // calculate normalized difference of band 4 and band 7 (B4-B7)/(B4+B7)
                  // .multiply(1000).multiply(distDir)                                          // ...scale results by 1000 so we can convert to int and retain some precision
                  .select([0], ['NBR'])                                    // ...name the band
                  .set('system:time_start', img.get('system:time_start')) // ...set the output system:time_start metadata to the input image time_start otherwise it is null
                  .set('year', img.get('year'));
    return index ;
};

var NDVIindex = function(img) {
    var index = img.normalizedDifference(['B4', 'B3'])                      // calculate normalized difference of band 4 and band 3 (B4-B3)/(B4+B3)
                  // .multiply(1000).multiply(distDir)                                          // ...scale results by 1000 so we can convert to int and retain some precision
                  .select([0], ['NDVI'])                                    // ...name the band
                  .set('system:time_start', img.get('system:time_start')) // ...set the output system:time_start metadata to the input image time_start otherwise it is null
                  .set('year', img.get('year'));
    return index ;
};


//----- BUILD LT COLLECTION -----
// build annual surface reflection collection
var annualSRcollection = buildMosaicCollection(startYear, endYear, startDay, endDay, aoi, dummyCollection); // put together the cloud-free medoid surface reflectance annual time series collection
print(annualSRcollection)


//== Build annual seasonal median composite
var medianSeries = ee.ImageCollection(buildAnnualMedian);
print(medianSeries)

//== Apply NBRindex function to calculate an NBR composite time series
var NBRMedseries = medianSeries.map(NBRindex);
print(NBRMedseries)

//== Apply NDVIindex function to calculate an NBR composite time series
var NDVIMedseries = medianSeries.map(NDVIindex);
print(NDVIMedseries)



//********************************************************************************************************
//****************************** *Export image collection *******************************
//********************************************************************************************************

var batch = require('users/fitoprincipe/geetools:batch')



batch.Download.ImageCollection.toDrive(NDVIMedseries, 'Landsat_NDVI', {
  name:'CL_ndvi_{year}',
  scale:30,
  region:study_area})


```

#### Import NDVI rasters {-}

```{r eval=FALSE}
#list the files
# lidar_list<-list.files(path='0_data/external/CL_LiDAR/CL_raster_mosaics/', pattern = "*.tif$", full.names = TRUE)
ndvi_list<-list.files(path='0_data/external/CL_Landsat_NDVI', pattern = "*.tif$", full.names = TRUE)
ndvi_stack<-raster::stack(ndvi_list)

zndvi_stack_pr<-projectRaster(ndvi_stack, crs=lidar_stack)

#save stack as r object
stackSave(ndvi_stack,file="0_data/external/CL_Landsat_NDVI/ndvi_stack.stk")

##############################################################################
##Plot the first layer of the raster.

#set up basemap
# base<-read_osm(c_bb, type="bing", minNumTiles = 10)

# stations
load("0_data/manual/bird/ss_xy.rData")

#alberta boundary
alberta<-st_read("../../data/spatial/external/Alberta_Boundaries_and_Roads/Alberta/Alberta.shp")


mainmap<-#tm_shape(base)+
  #tm_rgb()+ # to color the satelite basemap
  tm_shape(ndvi_stack[[1]])+
  tm_raster(style = "cont",title="1990 mean summer NDVI", breaks = NULL,
            )+
  tm_shape(ss_xy)+
    tm_symbols(shape = 4, alpha = 1, size = .6, col = "red")+
  tm_scale_bar(position=c("left", "BOTTOM"), text.color = "black", color.light="lightgrey")+
  tm_graticules(lines=FALSE)+
  tm_legend(outside=TRUE)

insetmap<-tm_shape(alberta)+tm_fill(col="lightgrey")+tm_borders(lwd=.9, col="black")+
  tm_shape(c_bb)+tm_borders(lw=2, col="red") +
  tm_layout(inner.margins = c(0.04,0.04,0.04,0.04), outer.margins=c(0,0,0,0), bg.color="transparent", frame = FALSE)
    #tm_symbols(shape = 20, alpha = .5, border.col="dimgray", size = .1, col = "black")
  #tm_legend(position=c("left", "top"), frame=TRUE)

#Get aspect ratio of bounding box
c_bb_2<-st_bbox(c_bb)
asp <- (c_bb_2$ymax - c_bb_2$ymin)/(c_bb_2$xmax - c_bb_2$xmin)


library(grid)
w <- 1
h <- asp * w
vp <- viewport(0.7, 0.33, width = w, height=h)
#vp <- viewport(0.9, 0.22, width = w, height=h, just=c("right", "top"))

tmap_save(mainmap,filename="3_output/maps/ndvi_inset.png",
          dpi=300, insets_tm=insetmap, insets_vp=vp,
          height=asp*350, width=350, units="mm")
```


```{r  echo=FALSE, fig.cap= "1990 mean summer NDVI. The first layer of the NDVI raster stack.", out.width = '100%'}
knitr::include_graphics("3_output/maps/ndvi_inset.png")
```

### Summarize NDVI {-}

Check the extreme values if the raster stack to identity any values that shouldn't be included (e.g. -9999).

```{r extremeValues, eval=FALSE}
#load stack
ndvi_stack<-stackOpen("0_data/external/CL_Landsat_NDVI/ndvi_stack.stk")

min(ndvi_stack)
max(ndvi_stack)

print(min)
print(max)
```
 The values appear normal. Next I summarized ndvi within 100 m of each point count location.

```{r eval=FALSE}
load("0_data/manual/bird/ss_xy.rData")

#rename raster names to remove "cl_" prefix
names(ndvi_stack) <- substring(names(ndvi_stack), 4)

ss_xy<-st_transform(ss_xy, crs(ndvi_stack))
ss_ndvi<-raster::extract(ndvi_stack,ss_xy, buffer=100, na.rm=TRUE, fun=mean) 

ss_ndvi_df<-data.frame("SS"=ss_xy$SS, ss_ndvi)


save(ss_ndvi_df, file="0_data/manual/spatialCov/ndvi/ss_ndvi_df.rData")
write.csv(ss_ndvi_df, file = "0_data/manual/spatialCov/ndvi/ss_ndvi_df.csv")
```

```{r echo=FALSE, message = FALSE, results="asis"}
load("0_data/manual/spatialCov/ndvi/ss_ndvi_df.rData")

knitr::kable(head(ss_ndvi_df)) %>%
  kable_styling(font_size = 10, bootstrap_options= c("striped", "hover", "condensed" ), full_width= F, position="center") %>%
  column_spec(1, width= "20em")%>%
  scroll_box(width = "100%", height = "400px")
```

